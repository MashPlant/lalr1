use hashbrown::HashMap;
use smallvec::SmallVec;
use crate::{
  RawGrammar, RawProduction, RawProductionRhs, Assoc, AbstractGrammar, AbstractGrammarExt,
  VALID_NAME,
};

pub type ProdVec = SmallVec<[u32; 6]>;

#[derive(Debug)]
pub struct Grammar<'a> {
  pub raw: &'a RawGrammar,
  //                 name
  pub terms: Vec<(&'a str, Option<(u32, Assoc)>)>,
  //          (name   , type_  )>
  pub nt: Vec<(&'a str, &'a str)>,
  pub prod: Vec<Vec<(ProdVec, u32)>>,
  //                   (act, arg)                     (lhs, index of this prod in raw.prod[lhs]) pri
  pub prod_extra: Vec<((&'a str, Option<&'a Vec<(Option<String>, String)>>), (u32, u32), Option<u32>)>,
}

impl Grammar<'_> {
  pub fn show_token(&self, id: u32) -> &str {
    if id < self.nt_num() {
      self.nt[id as usize].0
    } else {
      self.terms[id as usize - self.nt.len()].0
    }
  }

  pub fn show_prod(&self, id: u32) -> String {
    let (_, (lhs, idx), _) = self.prod_extra[id as usize];
    let (prod, _) = &self.prod[lhs as usize][idx as usize];
    let mut s = format!("{} -> ", self.nt[lhs as usize].0);
    for &rhs in prod {
      s += self.show_token(rhs);
      s.push(' ');
    }
    s.pop();
    s
  }
}

// will add a production _Start -> Start, so need mut
pub fn extend_grammar(raw: &mut RawGrammar) -> Result<Grammar, String> {
  let (terms, term2id) = crate::parse_term(&raw.priority, &raw.lexical)?;
  let mut nt = Vec::new();
  let mut nt2id = HashMap::new();

  if raw.production.is_empty() {
    return Err("Grammar must have at least one production rule.".into());
  }

  // 2 pass scan, so a non-term can be used before declared

  // getting production must be after this mut operation
  // this may seem stupid...
  let start = {
    let start = raw.start.clone().unwrap_or_else(|| raw.production[0].lhs.clone());
    raw.production.push(RawProduction {
      lhs: format!("_{}", start),
      // determine later
      type_: "".to_owned(),
      rhs: vec![RawProductionRhs {
        rhs: start.clone(),
        act: "_1".to_owned(),
        // the type "" is invalid, but will not be checked
        rhs_arg: Some(vec![(Some("_1".to_owned()), "".to_owned())]),
        prec: None,
      }],
    });
    start
  };

  for prod in &raw.production {
    let lhs = prod.lhs.as_str();
    // again this may seem stupid...
    // raw.production.last().unwrap().lhs is generated by the code above
    if !VALID_NAME.is_match(lhs) && lhs != &raw.production.last().unwrap().lhs {
      return Err(format!("Non-term is not a valid variable name: `{}`.", lhs));
    } else if term2id.contains_key(lhs) {
      return Err(format!("Non-term has a duplicate name with term: `{}`.", lhs));
    } else {
      match nt2id.get(lhs) {
        None => {
          let id = nt.len() as u32;
          nt.push((lhs, prod.type_.as_str()));
          nt2id.insert(lhs, id);
        }
        Some(&old) => if prod.type_.as_str() != nt[old as usize].1 {
          return Err(format!("Non-term `{}` is assigned to different types: `{}` and `{}`.", lhs, nt[old as usize].1, prod.type_));
        }
      };
    }
  }
  // set the type of _Start the same as Start
  nt.last_mut().unwrap().1 = nt[nt2id[start.as_str()] as usize].1;

  let mut prod = vec![Vec::new(); nt.len()];
  let mut prod_extra = Vec::new();
  let mut prod_id = 0u32;

  for (idx, raw_prod) in raw.production.iter().enumerate() {
    let lhs = nt2id.get(raw_prod.lhs.as_str()).unwrap();
    let lhs_prod = &mut prod[*lhs as usize];
    for rhs in &raw_prod.rhs {
      let mut prod_rhs = ProdVec::new();
      let mut prod_pri = None;
      for rhs in rhs.rhs.split_whitespace() {
        // impossible to have a (Some(), Some()) here
        match (nt2id.get(rhs), term2id.get(rhs)) {
          (Some(&nt), _) => prod_rhs.push(nt),
          (_, Some(&t)) => {
            prod_rhs.push(t + nt.len() as u32);
            prod_pri = terms[t as usize].1.map(|(pri, _)| pri);
          }
          _ => return Err(format!("Production rhs contains undefined token: `{}`", rhs)),
        }
      }
      if let Some(prec) = rhs.prec.as_ref() {
        match term2id.get(prec.as_str()) {
          None => return Err(format!("Prec uses undefined term: `{}`", prec)),
          Some(&t) => {
            prod_pri = terms[t as usize].1.map(|(pri, _)| pri);
          }
        }
      }
      let id = lhs_prod.len() as u32;
      lhs_prod.push((prod_rhs, prod_id));
      prod_extra.push(((rhs.act.as_str(), rhs.rhs_arg.as_ref()), (*lhs, id), prod_pri));
      prod_id += 1;

      // no type checking for _Start
      if idx == raw.production.len() - 1 { break; }
      // type checking
      if let Some(rhs_arg) = &rhs.rhs_arg {
        let rhs_tk = rhs.rhs.split_whitespace().collect::<Vec<_>>();
        if rhs_arg.len() != rhs_tk.len() {
          return Err(format!("Production `{} -> {}`'s rhs and method's arguments have different length: {} vs {}.",
                             raw_prod.lhs, rhs.rhs, rhs_tk.len(), rhs_arg.len()));
        }
        for (&rhs_tk, (_, rhs_ty)) in rhs_tk.iter().zip(rhs_arg.iter()) {
          match (nt2id.get(rhs_tk), term2id.get(rhs_tk)) {
            (Some(&nt_id), _) => {
              let nt_ty = &nt[nt_id as usize].1;
              if nt_ty != rhs_ty {
                return Err(format!("Production `{} -> {}`'s rhs and method's arguments have conflict signature: `{}` requires `{}`, while method takes `{}`.",
                                   raw_prod.lhs, rhs.rhs, rhs_tk, nt_ty, rhs_ty));
              }
            }
            (_, Some(_)) => if !rhs_ty.starts_with("Token") { // maybe user will use some lifetime specifier
              return Err(format!("Production `{} -> {}`'s rhs and method 's arguments have conflict signature: `{}` requires Token, while method takes `{}`.",
                                 raw_prod.lhs, rhs.rhs, rhs_tk, rhs_ty));
            }
            _ => {} // unreachable, because checked above
          }
        }
      }
    }
  }
  Ok(Grammar { raw, nt, terms, prod, prod_extra })
}

impl<'a> AbstractGrammar<'a> for Grammar<'a> {
  type ProdRef = ProdVec;
  type ProdIter = &'a Vec<(ProdVec, u32)>;

  fn start(&'a self) -> (u32, &'a (Self::ProdRef, u32)) {
    let last = self.prod.len() - 1;
    (last as u32, &self.prod[last][0])
  }

  // assume first term
  fn eps(&self) -> u32 {
    self.prod.len() as u32
  }

  // assume second term
  fn eof(&self) -> u32 {
    self.prod.len() as u32 + 1
  }

  // assume third term
  fn err(&self) -> u32 {
    self.prod.len() as u32 + 2
  }

  fn token_num(&self) -> u32 {
    self.terms.len() as u32 + self.prod.len() as u32
  }

  fn nt_num(&self) -> u32 {
    self.prod.len() as u32
  }

  fn get_prod(&'a self, lhs: u32) -> Self::ProdIter {
    &self.prod[lhs as usize]
  }
}

impl<'a> AbstractGrammarExt<'a> for Grammar<'a> {
  fn prod_pri(&self, id: u32) -> Option<u32> {
    self.prod_extra[id as usize].2
  }

  fn term_pri_assoc(&self, ch: u32) -> Option<(u32, Assoc)> {
    self.terms[ch as usize - self.nt.len()].1
  }
}