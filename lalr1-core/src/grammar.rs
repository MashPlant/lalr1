use std::collections::HashMap;
use smallvec::SmallVec;
use grammar_config::{
  RawGrammar, RawProduction, RawProductionRhs, Assoc, AbstractGrammar, AbstractGrammarExt,
  VALID_NAME,
};

pub type ProdVec = SmallVec<[u32; 6]>;

#[derive(Debug)]
pub struct Grammar<'a> {
  pub raw: &'a RawGrammar,
  //                 name
  pub terms: Vec<(&'a str, Option<(u32, Assoc)>)>,
  //          (name   , type_  )>
  pub nt: Vec<(&'a str, &'a str)>,
  pub prod: Vec<Vec<(ProdVec, u32)>>,
  //                   act      (lhs, index of this prod in raw.prod[lhs])
  pub prod_extra: Vec<(&'a str, (u32, u32), Option<(u32, Assoc)>)>,
}

// will add a production _Start -> Start, so need mut
pub fn extend_grammar(raw: &mut RawGrammar) -> Result<Grammar, String> {
  let (terms, term2id) = grammar_config::parse_term(&raw.priority, &raw.lexical)?;
  let mut nt = Vec::new();
  let mut nt2id = HashMap::new();

  if raw.production.is_empty() {
    return Err("Grammar must have at least one production rule.".into());
  }

  // 2 pass scan, so a terminal can be used before declared

  // getting production must be after this mut operation
  // this may seem stupid...
  {
    let start = raw.start.clone().unwrap_or_else(|| (raw.production[0].lhs.clone(), raw.production[0].type_.clone()));
    raw.production.push(RawProduction {
      lhs: format!("_{}", start.0),
      type_: start.1,
      rhs: vec![RawProductionRhs {
        rhs: start.0,
        act: "let _0 = _1;".into(),
        rhs_arg: unimplemented!(),
        prec: None,
      }],
    });
  }

  for prod in &raw.production {
    let lhs = prod.lhs.as_str();
    // again this may seem stupid...
    // raw.production.last().unwrap().lhs is generated by the code above
    if !VALID_NAME.is_match(lhs) && lhs != &raw.production.last().unwrap().lhs {
      return Err(format!("Non-terminal is not a valid variable name: `{}`.", lhs));
    } else if term2id.contains_key(lhs) {
      return Err(format!("Non-terminal has a duplicate name with terminal: `{}`.", lhs));
    } else {
      nt2id.entry(lhs).or_insert_with(|| {
        let id = nt.len() as u32;
        nt.push((lhs, prod.type_.as_str()));
        id
      });
    }
  }

  let mut prod = vec![Vec::new(); nt.len()];
  let mut prod_extra = Vec::new();
  let mut prod_id = 0u32;

  for raw in &raw.production {
    let lhs = nt2id.get(raw.lhs.as_str()).unwrap();
    let lhs_prod = &mut prod[*lhs as usize];
    for rhs in &raw.rhs {
      let mut prod_rhs = ProdVec::new();
      let mut pri_assoc = None;
      for rhs in rhs.rhs.split_whitespace() {
        // impossible to have a (Some(), Some()) here
        match (nt2id.get(rhs), term2id.get(rhs)) {
          (Some(&nt), _) => prod_rhs.push(nt),
          (_, Some(&t)) => {
            prod_rhs.push(t + nt.len() as u32);
            pri_assoc = terms[t as usize].1;
          }
          _ => return Err(format!("Production rhs contains undefined item: `{}`", rhs)),
        }
      }
      if let Some(prec) = rhs.prec.as_ref() {
        match term2id.get(prec.as_str()) {
          None => return Err(format!("Prec uses undefined terminal: `{}`", prec)),
          Some(&t) => {
            pri_assoc = terms[t as usize].1;
          }
        }
      }
      let id = lhs_prod.len() as u32;
      lhs_prod.push((prod_rhs, prod_id));
      prod_extra.push((rhs.act.as_str(), (*lhs, id), pri_assoc));
      prod_id += 1;
    }
  }

  Ok(Grammar { raw, nt, terms, prod, prod_extra })
}

impl<'a> AbstractGrammar<'a> for Grammar<'a> {
  type ProdRef = ProdVec;
  type ProdIter = &'a Vec<(ProdVec, u32)>;

  fn start(&'a self) -> &'a (Self::ProdRef, u32) {
    &self.prod.last().unwrap()[0]
  }

  // first terminal
  fn eps(&self) -> u32 {
    self.prod.len() as u32
  }

  // second terminal
  fn eof(&self) -> u32 {
    self.prod.len() as u32 + 1
  }

  fn token_num(&self) -> u32 {
    self.terms.len() as u32 + self.prod.len() as u32
  }

  fn nt_num(&self) -> u32 {
    self.prod.len() as u32
  }

  fn get_prod(&'a self, lhs: u32) -> Self::ProdIter {
    &self.prod[lhs as usize]
  }
}

impl<'a> AbstractGrammarExt<'a> for Grammar<'a> {
  fn prod_pri_assoc(&self, id: u32) -> Option<(u32, Assoc)> {
    self.prod_extra[id as usize].2
  }

  fn term_pri_assoc(&self, ch: u32) -> Option<(u32, Assoc)> {
    self.terms[ch as usize - self.nt.len()].1
  }
}