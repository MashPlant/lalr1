use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use smallvec::SmallVec;
use grammar_config::{RawGrammar, RawProduction, RawProductionRhs, Assoc, AbstractGrammar, AbstractGrammarExt, EOF, EPS};

pub type ProdVec = SmallVec<[u32; 6]>;

#[derive(Debug)]
pub struct Grammar<'a> {
  pub raw: &'a RawGrammar,
  //                 name
  pub terminal: Vec<(&'a str, Option<(u32, Assoc)>)>,
  //          (name   , type_  )>
  pub nt: Vec<(&'a str, &'a str)>,
  pub prod: Vec<Vec<(ProdVec, u32)>>,
  //                   act      (lhs, index of this prod in raw.prod[lhs])
  pub prod_extra: Vec<(&'a str, (u32, u32), Option<(u32, Assoc)>)>,
}

// will add a production _Start -> Start, so need mut
pub fn extend_grammar(raw: &mut RawGrammar) -> Result<Grammar, String> {
  let valid_name = regex::Regex::new("^[a-zA-Z][a-zA-Z_0-9]*$").unwrap();
  let mut terminal = vec![(EPS, None), (EOF, None)];
  let mut terminal2id = HashMap::new();
  terminal2id.insert(EPS, 0);
  terminal2id.insert(EOF, 1);
  let mut nt = Vec::new();
  let mut nt2id = HashMap::new();

  for (pri, term_row) in raw.terminal.iter().enumerate() {
    let pri_assoc = term_row.assoc.map(|assoc| (pri as u32, assoc));
    for term in term_row.terms.iter().map(String::as_str) {
      if term == EPS {
        return Err(format!("Terminal cannot have builtin name `{}`.", EPS));
      } else if term == EOF {
        return Err(format!("Terminal cannot have builtin name `{}`.", EOF));
      } else if !valid_name.is_match(term) {
        return Err(format!("Terminal is not a valid variable name: `{}`.", term));
      } else if terminal2id.contains_key(term) {
        return Err(format!("Find duplicate token: `{}`.", term));
      } else {
        terminal2id.insert(term, terminal.len() as u32);
        terminal.push((term, pri_assoc));
      }
    }
  }

  for l in &raw.lexical {
    let (_, term) = (l.0.as_str(), l.1.as_str());
    if term == EOF {
      return Err(format!("User define lex rule cannot return token `{}`.", EOF));
    } else if term != EPS && !valid_name.is_match(term) {
      return Err(format!("Token is not a valid variable name: `{}`.", term));
    }
    terminal2id.entry(term).or_insert_with(|| {
      let id = terminal.len() as u32;
      terminal.push((term, None));
      id
    });
  }

  if raw.production.is_empty() {
    return Err("Grammar must have at least one production rule.".into());
  }

  // 2 pass scan, so a terminal can be used before declared

  // getting production must be after this mut operation
  // this may seem stupid...
  {
    let start = raw.start.clone().unwrap_or_else(|| (raw.production[0].lhs.clone(), raw.production[0].type_.clone()));
    raw.production.push(RawProduction {
      lhs: format!("_{}", start.0),
      type_: start.1,
      rhs: vec![RawProductionRhs {
        rhs: start.0,
        act: "let _0 = _1;".into(),
        prec: None,
      }],
    });
  }

  for prod in &raw.production {
    let lhs = prod.lhs.as_str();
    // again this may seem stupid...
    // raw.production.last().unwrap().lhs is generated by the code above
    if !valid_name.is_match(lhs) && lhs != &raw.production.last().unwrap().lhs {
      return Err(format!("Non-terminal is not a valid variable name: `{}`.", lhs));
    } else if terminal2id.contains_key(lhs) {
      return Err(format!("Non-terminal has a duplicate name with terminal: `{}`.", lhs));
    } else {
      nt2id.entry(lhs).or_insert_with(|| {
        let id = nt.len() as u32;
        nt.push((lhs, prod.type_.as_str()));
        id
      });
    }
  }

  let mut prod = vec![Vec::new(); nt.len()];
  let mut prod_extra = Vec::new();
  let mut prod_id = 0u32;

  for raw in &raw.production {
    let lhs = nt2id.get(raw.lhs.as_str()).unwrap();
    let lhs_prod = &mut prod[*lhs as usize];
    for rhs in &raw.rhs {
      let mut prod_rhs = ProdVec::new();
      let mut pri_assoc = None;
      for rhs in rhs.rhs.split_whitespace() {
        // impossible to have a (Some(), Some()) here
        match (nt2id.get(rhs), terminal2id.get(rhs)) {
          (Some(&nt), _) => prod_rhs.push(nt),
          (_, Some(&t)) => {
            prod_rhs.push(t + nt.len() as u32);
            pri_assoc = terminal[t as usize].1;
          }
          _ => return Err(format!("Production rhs contains undefined item: `{}`", rhs)),
        }
      }
      if let Some(prec) = rhs.prec.as_ref() {
        match terminal2id.get(prec.as_str()) {
          None => return Err(format!("Prec uses undefined terminal: `{}`", prec)),
          Some(&t) => {
            pri_assoc = terminal[t as usize].1;
          }
        }
      }
      let id = lhs_prod.len() as u32;
      lhs_prod.push((prod_rhs, prod_id));
      prod_extra.push((rhs.act.as_str(), (*lhs, id), pri_assoc));
      prod_id += 1;
    }
  }

  Ok(Grammar {
    raw: raw,
    nt,
    terminal,
    prod,
    prod_extra,
  })
}

impl<'a> AbstractGrammar<'a> for Grammar<'a> {
  type ProdRef = ProdVec;
  type ProdIter = &'a Vec<(ProdVec, u32)>;

  fn start(&'a self) -> &'a (Self::ProdRef, u32) {
    &self.prod.last().unwrap()[0]
  }

  // first terminal
  fn eps(&self) -> u32 {
    self.prod.len() as u32
  }

  // second terminal
  fn eof(&self) -> u32 {
    self.prod.len() as u32 + 1
  }

  fn token_num(&self) -> u32 {
    self.terminal.len() as u32 + self.prod.len() as u32
  }

  fn nt_num(&self) -> u32 {
    self.prod.len() as u32
  }

  fn get_prod(&'a self, lhs: u32) -> Self::ProdIter {
    &self.prod[lhs as usize]
  }
}

impl<'a> AbstractGrammarExt<'a> for Grammar<'a> {
  fn prod_pri_assoc(&self, id: u32) -> Option<(u32, Assoc)> {
    self.prod_extra[id as usize].2
  }

  fn term_pri_assoc(&self, ch: u32) -> Option<(u32, Assoc)> {
    self.terminal[ch as usize - self.nt.len()].1
  }
}