{include}

{macros}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum TokenKind { {token_kind} }

pub enum StackItem<'p> { {stack_item} }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct Token<'l> {
  pub ty: TokenKind,
  pub piece: &'l [u8],
  pub line: u32,
  pub col: u32,
}

pub struct Lexer<'l> {
  pub string: &'l [u8],
  pub cur_line: u32,
  pub cur_col: u32,
}

impl<'l> Lexer<'l> {
  pub fn new(string: &[u8]) -> Lexer {
    Lexer { string, cur_line: 1, cur_col: 1 }
  }

  pub fn next(&mut self) -> Token<'l> {
    static ACC: [TokenKind; {dfa_size}] = [{acc}];
    static EC: [u8; 256] = [{ec}];
    static DFA_EDGE: [[{u_dfa_size}; {ec_size}]; {dfa_size}] = [{dfa_edge}];
    loop {
      if self.string.is_empty() {
        return Token { ty: TokenKind::_Eof, piece: "".as_bytes(), line: self.cur_line, col: self.cur_col };
      }
      let (mut line, mut col) = (self.cur_line, self.cur_col);
      let mut last_acc = TokenKind::_Err; // this is arbitrary, just a value that cannot be returned by user defined function
      let mut state = 0;
      let mut i = 0;
      while i < self.string.len() {
        let ch = index!(self.string, i);
        let ec = index!(EC, ch);
        let nxt = index!(index!(DFA_EDGE, state), ec);
        let acc = index!(ACC, nxt);
        last_acc = if acc != TokenKind::_Err { acc } else { last_acc };
        state = nxt;
        if nxt == 0 { // dead, should not eat this char
          let piece = &self.string[..i];
          self.string = &self.string[i..];
          if last_acc != TokenKind::_Eps {
            return Token { ty: last_acc, piece, line, col };
          } else {
            line = self.cur_line;
            col = self.cur_col;
            last_acc = TokenKind::_Err;
            state = 0;
            i = 0;
          }
        } else { // continue, eat this char
          if ch == b'\n' {
            self.cur_line += 1;
            self.cur_col = 1;
          } else {
            self.cur_col += 1;
          }
          i += 1;
        }
      }
      // end of file
      let piece = &self.string[..i];
      self.string = &self.string[i..];
      if last_acc != TokenKind::_Eps {
        return Token { ty: last_acc, piece, line, col };
      } else {
        return Token { ty: TokenKind::_Eof, piece: "".as_bytes(), line: self.cur_line, col: self.cur_col };
      }
    }
  }
}

{parser_struct}