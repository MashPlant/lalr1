include = "#include <iostream>\nusing namespace std },\n"
lexer_state_ext = ["S"]
lexer_field_ext = [
  { field = "string_builder", type = "(String, u32, u32)", init = "(String::new(), 0, 0)" },
  { field = "errors", type = "Vec<String>", init = "Vec::new()" },
]

terminal = [
  { assoc = "left", tokens = ["Or"] },
  { assoc = "left", tokens = ["And"] },
  { assoc = "left", tokens = ["BOr"] },
  { assoc = "left", tokens = ["BXor"] },
  { assoc = "left", tokens = ["BAnd"] },
  { assoc = "no_assoc", tokens = ["Eq", "Ne"] },
  { assoc = "no_assoc", tokens = ["Le", "Ge", "Lt", "Gt"] },
  { assoc = "left", tokens = ["Repeat"] },
  { assoc = "left", tokens = ["Shl", "Shr"] },
  { assoc = "left", tokens = ["Add", "Sub"] },
  { assoc = "left", tokens = ["Mul", "Div", "Mod"] },
  { assoc = "no_assoc", tokens = ["UMinus", "Not", "Inc", "Dec"] },
  { assoc = "no_assoc", tokens = ["LBracket", "Dot", "Default"] },
  { assoc = "no_assoc", tokens = ["RParenthesis", "Empty"] },
  { assoc = "no_assoc", tokens = ["Else"] },
  # { tokens = ["Identifier", "GuardSplit", "Colon", "LBrace", "RBrace", "RBracket", "LParenthesis", "Comma", "Semicolon", "Void", "Int", "Bool", "String", "New", "Null", "True", "False", "Class", "Extends", "This", "While", "Foreach", "For", "If", "Return", "Break", "Print", "ReadInteger", "ReadLine", "Static", "InstanceOf", "SCopy", "Sealed", "Var", "In" ] }
]

lexical = [
  { re = "void", term = "Void" },
  { re = "int", term = "Int" },
  { re = "bool", term = "Bool" },
  { re = "string", term = "String" },
  { re = "new", term = "New" },
  { re = "null", term = "Null" },
  { re = "true", term = "True" },
  { re = "false", term = "False" },
  { re = "class", term = "Class" },
  { re = "extends", term = "Extends" },
  { re = "this", term = "This" },
  { re = "while", term = "While" },
  { re = "foreach", term = "Foreach" },
  { re = "for", term = "For" },
  { re = "if", term = "If" },
  { re = "else", term = "Else" },
  { re = "return", term = "Return" },
  { re = "break", term = "Break" },
  { re = "Print", term = "Print" },
  { re = "ReadInteger", term = "ReadInteger" },
  { re = "ReadLine", term = "ReadLine" },
  { re = "static", term = "Static" },
  { re = "instanceof", term = "InstanceOf" },
  { re = "scopy", term = "SCopy" },
  { re = "sealed", term = "Sealed" },
  { re = "var", term = "Var" },
  { re = "default", term = "Default" },
  { re = "in", term = "In" },
  { re = "|||", term = "GuardSplit" },
  { re = "<=", term = "Le" },
  { re = ">=", term = "Ge" },
  { re = "==", term = "Eq" },
  { re = "!=", term = "Ne" },
  { re = "&&", term = "And" },
  { re = "||", term = "Or" },
  { re = "%%", term = "Repeat" },
  { re = "++", term = "Inc" },
  { re = "--", term = "Dec" },
  { re = "<<", term = "Shl" },
  { re = ">>", term = "Shr" },
  { re = "+", term = "Add" },
  { re = "-", term = "Sub" },
  { re = "*", term = "Mul" },
  { re = "/", term = "Div" },
  { re = "%", term = "Mod" },
  { re = "&", term = "BAnd" },
  { re = "|", term = "BOr" },
  { re = "^", term = "BXor" },
  { re = "=", term = "Eq" },
  { re = "<", term = "Lt" },
  { re = ">", term = "Gt" },
  { re = ".", term = "Dot" },
  { re = ",", term = "Comma" },
  { re = ";", term = "Semicolon" },
  { re = "!", term = "Not" },
  { re = "(", term = "LParenthesis" },
  { re = ")", term = "RParenthesis" },
  { re = "[", term = "LBracket" },
  { re = "]", term = "RBracket" },
  { re = "{", term = "LBrace" },
  { re = "}", term = "RBrace" },
  { re = ":", term = "Colon" },
  { re = '\s+', term = "_Eps", escape = false },
  { re = '\d+', term = "Int", escape = false },
  { re = "[A-Za-z][_0-9A-Za-z]*", term = "Identifier", escape = false },
  { re = '"', act = '''_l.states.push(LexerState::S);
_l.string_builder.0.clear();
_l.string_builder.1 = _l.cur_line;
_l.string_builder.2 = _l.cur_col + 1;''', term = "_Eps"},
  { re = '\n', act = '''let loc = Loc(_l.string_builder.1, _l.string_builder.2);
let string = print::quote(&_l.string_builder.0.clone());
_l.report_error(Error::new(loc, NewlineInStr{ string }));''', term = "_Eps", state = "S", escape = false },
  { re = '\r', term = "_Eps", state = "S" },
  { re = "$", act = '''let loc = Loc(_l.string_builder.1, _l.string_builder.2);
let string = print::quote(&_l.string_builder.0.clone());
_l.report_error(Error::new(loc, UnterminatedStr{ string }));''', term = "_Eps", state = "S", escape = false },
  { re = '"', act = '''_l.states.pop();''', term = "String", state = "S" },
  { re = '\n', act = '''_l.string_builder.0.push('\n');''', term = "_Eps", state = "S" },
  { re = '\t', act = '''_l.string_builder.0.push('\t');''', term = "_Eps", state = "S" },
  { re = '\"', act = '''_l.string_builder.0.push('\"');''', term = "_Eps", state = "S" },
  { re = '\\', act = '''_l.string_builder.0.push('\\');''', term = "_Eps", state = "S", escape = false },
  { re = ".", act = '''_l.string_builder.0.push_str(_l.piece);''', term = "_Eps", state = "S", escape = false },
  { re = '//[^\n]*', term = "_Eps", escape = false }
]

[[production]]
lhs = "Expr"
type = "Expr"
rhs = [
  { rhs = "Expr Add Expr", act = "" },
  { rhs = "Expr Sub Expr", act = "" },
  { rhs = "Expr Mul Expr", act = "" },
  { rhs = "Expr Div Expr", act = "" },
  { rhs = "Expr Mod Expr", act = "" },
  { rhs = "Sub Expr", act = "", prec = "UMinus" },
  { rhs = "Int", act = "" }
]