include = "#include <iostream>\nusing namespace std },\n"
lexer_state_ext = ["S"]
lexer_field_ext = [
  { field = "string_builder", type = "(String, u32, u32)", init = "(String::new(), 0, 0)" },
  { field = "errors", type = "Vec<String>", init = "Vec::new()" },
]

token = [
  { assoc = "left", tokens = ["Or"] },
  { assoc = "left", tokens = ["And"] },
  { assoc = "left", tokens = ["BOr"] },
  { assoc = "left", tokens = ["BXor"] },
  { assoc = "left", tokens = ["BAnd"] },
  { assoc = "no_assoc", tokens = ["Eq", "Ne"] },
  { assoc = "no_assoc", tokens = ["Le", "Ge", "Lt", "Gt"] },
  { assoc = "left", tokens = ["Repeat"] },
  { assoc = "left", tokens = ["Shl", "Shr"] },
  { assoc = "left", tokens = ["Add", "Sub"] },
  { assoc = "left", tokens = ["Mul", "Div", "Mod"] },
  { assoc = "no_assoc", tokens = ["UMinus", "Not", "Inc", "Dec"] },
  { assoc = "no_assoc", tokens = ["LBracket", "Dot", "Default"] },
  { assoc = "no_assoc", tokens = ["RParenthesis", "Empty"] },
  { assoc = "no_assoc", tokens = ["Else"] },
  { tokens = ["Identifier", "GuardSplit", "Colon", "LBrace", "RBrace", "RBracket", "LParenthesis", "Comma", "Semicolon", "Void", "Int", "Bool", "String", "New", "Null", "True", "False", "Class", "Extends", "This", "While", "Foreach", "For", "If", "Return", "Break", "Print", "ReadInteger", "ReadLine", "Static", "InstanceOf", "SCopy", "Sealed", "Var", "In" ] }
]

lexical = [
  { re = "void", act = "TokenType::Void" },
  { re = "int", act = "TokenType::Int" },
  { re = "bool", act = "TokenType::Bool" },
  { re = "string", act = "TokenType::String" },
  { re = "new", act = "TokenType::New" },
  { re = "null", act = "TokenType::Null" },
  { re = "true", act = "TokenType::True" },
  { re = "false", act = "TokenType::False" },
  { re = "class", act = "TokenType::Class" },
  { re = "extends", act = "TokenType::Extends" },
  { re = "this", act = "TokenType::This" },
  { re = "while", act = "TokenType::While" },
  { re = "foreach", act = "TokenType::Foreach" },
  { re = "for", act = "TokenType::For" },
  { re = "if", act = "TokenType::If" },
  { re = "else", act = "TokenType::Else" },
  { re = "return", act = "TokenType::Return" },
  { re = "break", act = "TokenType::Break" },
  { re = "Print", act = "TokenType::Print" },
  { re = "ReadInteger", act = "TokenType::ReadInteger" },
  { re = "ReadLine", act = "TokenType::ReadLine" },
  { re = "static", act = "TokenType::Static" },
  { re = "instanceof", act = "TokenType::InstanceOf" },
  { re = "scopy", act = "TokenType::SCopy" },
  { re = "sealed", act = "TokenType::Sealed" },
  { re = "var", act = "TokenType::Var" },
  { re = "default", act = "TokenType::Default" },
  { re = "in", act = "TokenType::In" },
  { re = "|||", act = "TokenType::GuardSplit" },
  { re = "<=", act = "TokenType::Le" },
  { re = ">=", act = "TokenType::Ge" },
  { re = "==", act = "TokenType::Eq" },
  { re = "!=", act = "TokenType::Ne" },
  { re = "&&", act = "TokenType::And" },
  { re = "||", act = "TokenType::Or" },
  { re = "%%", act = "TokenType::Repeat" },
  { re = "++", act = "TokenType::Inc" },
  { re = "--", act = "TokenType::Dec" },
  { re = "<<", act = "TokenType::Shl" },
  { re = ">>", act = "TokenType::Shr" },
  { re = "+", act = "TokenType::Add" },
  { re = "-", act = "TokenType::Sub" },
  { re = "*", act = "TokenType::Mul" },
  { re = "/", act = "TokenType::Div" },
  { re = "%", act = "TokenType::Mod" },
  { re = "&", act = "TokenType::BAnd" },
  { re = "|", act = "TokenType::BOr" },
  { re = "^", act = "TokenType::BXor" },
  { re = "=", act = "TokenType::Eq" },
  { re = "<", act = "TokenType::Lt" },
  { re = ">", act = "TokenType::Gt" },
  { re = ".", act = "TokenType::Dot" },
  { re = ",", act = "TokenType::Comma" },
  { re = ";", act = "TokenType::Semicolon" },
  { re = "!", act = "TokenType::Not" },
  { re = "(", act = "TokenType::LParenthesis" },
  { re = ")", act = "TokenType::RParenthesis" },
  { re = "[", act = "TokenType::LBracket" },
  { re = "]", act = "TokenType::RBracket" },
  { re = "{", act = "TokenType::LBrace" },
  { re = "}", act = "TokenType::RBrace" },
  { re = ":", act = "TokenType::Colon" },
  { re = '\s+', act = "TokenType::_Skip", escape = false },
  { re = '\d+', act = "TokenType::Int", escape = false },
  { re = "[A-Za-z][_0-9A-Za-z]*", act = "TokenType::Identifier", escape = false },
  { re = '"', act = '''_l.states.push(LexerState::S);
_l.string_builder.0.clear();
_l.string_builder.1 = _l.cur_line;
_l.string_builder.2 = _l.cur_col + 1;
TokenType::_Skip''' },
  { re = '\n', act = '''let loc = Loc(_l.string_builder.1, _l.string_builder.2);
let string = print::quote(&_l.string_builder.0.clone());
_l.report_error(Error::new(loc, NewlineInStr{ string }));
TokenType::_Skip''', state = "S", escape = false },
  { re = '\r', act = "TokenType::_Skip", state = "S" },
  { re = "$", act = '''let loc = Loc(_l.string_builder.1, _l.string_builder.2);
let string = print::quote(&_l.string_builder.0.clone());
_l.report_error(Error::new(loc, UnterminatedStr{ string }));
TokenType::_Skip''', state = "S", escape = false },
  { re = '"', act = '''_l.states.pop();
TokenType::String''', state = "S" },
  { re = '\n', act = '''_l.string_builder.0.push('\n');
TokenType::_Skip''', state = "S" },
  { re = '\t', act = '''_l.string_builder.0.push('\t');
TokenType::_Skip''', state = "S" },
  { re = '\"', act = '''_l.string_builder.0.push('\"');
TokenType::_Skip''', state = "S" },
  { re = '\\', act = '''_l.string_builder.0.push('\\');
TokenType::_Skip''', state = "S", escape = false },
  { re = ".", act = '''_l.string_builder.0.push_str(_l.piece);
TokenType::_Skip''', state = "S", escape = false },
  { re = '//[^\n]*', act = "TokenType::_Skip", escape = false }
]

production = [
]